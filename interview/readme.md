##q1
  - JavaScript全局执行上下文为我们创建了两个东西:全局对象和this关键字.
  - this 的作用域 全局的是指向windows 如果是一个函数里，作用域就在被调用的函数里面

#__proto__ 和 prototype 的区别 
  1. 万物都有__proto__,只有函数才有原型链(prototype) 对象没有原型链 
  2. 
    对象__proto__ 直接a.__proto__就能直接看到了
    但是函数b.__proto__ 看到是一个函数, 要b.__proto__.__proto__才能看到b的原型 
    相当于一个糖衣药片  对象的__proto__ 就能直接看到糖衣里面的药 但是函数的__proto__只能看到糖衣，要__proto__.__proto__才能看到糖衣里面包裹的东西

#new 方法的实现的原理
  1. 创建一个空对象，构造函数的this指向这个空对象
  2. 这个对象被执行一个原型链接的步骤
  3.  执行构造函数，将函数中的属性或方法加入到this引用的对象上面
  4. 如果构造函数中没有返回其他对象，那么返回this，即创建的新对象，否则，返回构造函数返回的对象


## q2  call,bind,apply
  1. b.call(a,5) 就相当吧b里面的作用域强行指向到a里面去,第一个参数一定是this作用域要去到的地方，后面的参数都是该作用域里面用到的逻辑参数
  2. b.apply(a,[9])  就相当吧b里面的作用域强行指向到a里面去,第一个参数一定是this作用域要去到的地方，后面的参数都是该作用域里面用到的逻辑参数,不同的是，后面的参数一定要用使用数组形式的值
  3. b.call() 或者 b.apply() 此时this的作用域会指向window
  4. var c = b.bind(a)
      c()
   bind改变函数内部this指向,指定函数c 的 this绑定为 a，与call的不同之处：产生一个新函数，之后在运行的时候，this就是被绑定的对象,
  var c = b.bind(a,5)
  c(3,4) 输出的是8  bind方法接收的参数是按照形参的顺序进行的

## q3 解构 和 浅拷贝和深拷贝
    // 浅拷贝和深拷贝  比如一个人，浅拷贝是拿人的影子来用，人死了，影子就没了，深拷贝的话就是我克隆一个人，就算那个真的人已经死了，克隆的人还在
  #浅拷贝
    浅拷贝  原数据改变，拷贝的数据也会变  被影响的非基础数据类型的数据才会被影响
  #深拷贝
    

